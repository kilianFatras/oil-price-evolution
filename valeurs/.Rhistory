b <- array(x[2] - x[1], n)
for(i in c(2:n))
{
l[i]<-xSmooth[i-1]+(1-(1-alpha)^2)*(x[i]-xSmooth[i-1])
b[i]<-b[i-1]+alpha^2*(x[i]-xSmooth[i-1])
xSmooth[i]<-l[i]+b[i]
}
xSmooth <- c(x[1], head(xSmooth, n-1))
return(xSmooth)
}
alpha <- seq(0.00, 0.95, length = 100)
forecast1<-lapply(alpha, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
forecast2<-lapply(alpha, doubleExpSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire transformer une liste en vecteur
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
####TD3 MAP STA 2
rm(list=objects())
library(magrittr)
library(forecast)
library(zoo)
library(xts)
n <- 100
t <- c(1:n)
s <- cos(2*t*pi/10)
eps = rnorm(n,0,1)
X1 = eps
X2 = eps + t/5
X3 = eps + cos(2*t*pi/10) + t/5
plot(X3, type = 'l', ylim = range(X1,X2,X3))
lines(X2-eps, col = 'red')
lines(X3-eps, col = 'blue')
#### Lissage Simple
expSmooth = function(x,alpha)
{
xSmooth <- x
n <- length(x)
for (i in c(2:n))
{
xSmooth[i] = alpha*x[i] + (1-alpha)*xSmooth[i-1]
}
xSmooth <- c(x[1], head(xSmooth, n-1))
return(xSmooth)
}
aplha = 0.9
X1.smooth <- expSmooth(X1, aplha )
plot(X1, type = 'l')
lines(X1.smooth, col = 'red')
mean((X1 - X1.smooth)^2)
##Optimisation alpha
alpha <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha, expSmooth, x=X1)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X1-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha, erreur, type = 'l')
o <- which.min(erreur)
points(alpha[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X2
aplha = 0.9
X2.smooth <- expSmooth(X2, aplha )
plot(X2, type = 'l')
lines(X2.smooth, col = 'red')
mean((X2 - X2.smooth)^2)
##Optimisation alpha
alpha_X2 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X2, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X2[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X3
aplha = 0.9
X3.smooth <- expSmooth(X3, aplha )
plot(X3, type = 'l')
lines(X3.smooth, col = 'red')
mean((X3 - X3.smooth)^2)
##Optimisation alpha
alpha_X3 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X3, expSmooth, x=X3)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X3-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X3, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
### Lissage Double
doubleExpSmooth = function(x, aplha)
{
xSmooth <- x
n = length(x)
l <- array(x[1], dim = n)
b <- array(x[2] - x[1], n)
for(i in c(2:n))
{
l[i]<-xSmooth[i-1]+(1-(1-alpha)^2)*(x[i]-xSmooth[i-1])
b[i]<-b[i-1]+alpha^2*(x[i]-xSmooth[i-1])
xSmooth[i]<-l[i]+b[i]
}
res<-list()
res$smooth<-xsmooth
res$l=l
res$b<-b
return(res)
}
alpha <- seq(0.00, 0.95, length = 100)
forecast1<-lapply(alpha, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
forecast2<-lapply(alpha, doubleExpSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire transformer une liste en vecteur
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
####TD3 MAP STA 2
rm(list=objects())
library(magrittr)
library(forecast)
library(zoo)
library(xts)
n <- 100
t <- c(1:n)
s <- cos(2*t*pi/10)
eps = rnorm(n,0,1)
X1 = eps
X2 = eps + t/5
X3 = eps + cos(2*t*pi/10) + t/5
plot(X3, type = 'l', ylim = range(X1,X2,X3))
lines(X2-eps, col = 'red')
lines(X3-eps, col = 'blue')
#### Lissage Simple
expSmooth = function(x,alpha)
{
xSmooth <- x
n <- length(x)
for (i in c(2:n))
{
xSmooth[i] = alpha*x[i] + (1-alpha)*xSmooth[i-1]
}
xSmooth <- c(x[1], head(xSmooth, n-1))
return(xSmooth)
}
aplha = 0.9
X1.smooth <- expSmooth(X1, aplha )
plot(X1, type = 'l')
lines(X1.smooth, col = 'red')
mean((X1 - X1.smooth)^2)
##Optimisation alpha
alpha <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha, expSmooth, x=X1)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X1-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha, erreur, type = 'l')
o <- which.min(erreur)
points(alpha[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X2
aplha = 0.9
X2.smooth <- expSmooth(X2, aplha )
plot(X2, type = 'l')
lines(X2.smooth, col = 'red')
mean((X2 - X2.smooth)^2)
##Optimisation alpha
alpha_X2 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X2, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X2[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X3
aplha = 0.9
X3.smooth <- expSmooth(X3, aplha )
plot(X3, type = 'l')
lines(X3.smooth, col = 'red')
mean((X3 - X3.smooth)^2)
##Optimisation alpha
alpha_X3 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X3, expSmooth, x=X3)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X3-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X3, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
### Lissage Double
doubleExpSmooth = function(x, aplha)
{
xSmooth <- x
n = length(x)
l <- array(x[1], dim = n)
b <- array(x[2] - x[1], n)
for(i in c(2:n))
{
l[i]<-xSmooth[i-1]+(1-(1-alpha)^2)*(x[i]-xSmooth[i-1])
b[i]<-b[i-1]+alpha^2*(x[i]-xSmooth[i-1])
xSmooth[i]<-l[i]+b[i]
}
res<-list()
res$smooth<-xSmooth
res$l=l
res$b<-b
return(res)
}
alpha <- seq(0.00, 0.95, length = 100)
forecast1<-lapply(alpha, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
forecast2<-lapply(alpha, doubleExpSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire transformer une liste en vecteur
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
####TD3 MAP STA 2
rm(list=objects())
library(magrittr)
library(forecast)
library(zoo)
library(xts)
n <- 100
t <- c(1:n)
s <- cos(2*t*pi/10)
eps = rnorm(n,0,1)
X1 = eps
X2 = eps + t/5
X3 = eps + cos(2*t*pi/10) + t/5
plot(X3, type = 'l', ylim = range(X1,X2,X3))
lines(X2-eps, col = 'red')
lines(X3-eps, col = 'blue')
#### Lissage Simple
expSmooth = function(x,alpha)
{
xSmooth <- x
n <- length(x)
for (i in c(2:n))
{
xSmooth[i] = alpha*x[i] + (1-alpha)*xSmooth[i-1]
}
xSmooth <- c(x[1], head(xSmooth, n-1))
return(xSmooth)
}
aplha = 0.9
X1.smooth <- expSmooth(X1, aplha )
plot(X1, type = 'l')
lines(X1.smooth, col = 'red')
mean((X1 - X1.smooth)^2)
##Optimisation alpha
alpha <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha, expSmooth, x=X1)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X1-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha, erreur, type = 'l')
o <- which.min(erreur)
points(alpha[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X2
aplha = 0.9
X2.smooth <- expSmooth(X2, aplha )
plot(X2, type = 'l')
lines(X2.smooth, col = 'red')
mean((X2 - X2.smooth)^2)
##Optimisation alpha
alpha_X2 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X2, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X2[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X3
aplha = 0.9
X3.smooth <- expSmooth(X3, aplha )
plot(X3, type = 'l')
lines(X3.smooth, col = 'red')
mean((X3 - X3.smooth)^2)
##Optimisation alpha
alpha_X3 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X3, expSmooth, x=X3)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X3-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X3, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
### Lissage Double
doubleExpSmooth = function(x, aplha)
{
xSmooth <- x
n = length(x)
l <- array(x[1], dim = n)
b <- array(x[2] - x[1], n)
for(i in c(2:n))
{
l[i]<-xSmooth[i-1]+(1-(1-alpha)^2)*(x[i]-xSmooth[i-1])
b[i]<-b[i-1]+alpha^2*(x[i]-xSmooth[i-1])
xSmooth[i]<-l[i]+b[i]
}
res<-list()
res$smooth<-xSmooth
res$l=l
res$b<-b
return(res)
}
alpha <- seq(0.00, 0.95, length = 100)
forecast1<-lapply(alpha, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
forecast2<-lapply(alpha, doubleExpSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur1<-lapply(forecast1,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire transformer une liste en vecteur
erreur2<-lapply(forecast2,function(x){mean((X2-x$Smooth)^2)})%>%unlist #correspond à faire transformer une liste en vecteur
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
grpahics.off()
graphics.off()
graphics.off()
plot(alpha, erreur2, type = 'l')
plot(alpha, erreur1, type = 'l')
o <- which.min(erreur)
plot(alpha, erreur2, type = 'l')
lines(alpha, erreur1, type = 'l')
plot(alpha, erreur2, type = 'l')
####TD3 MAP STA 2
rm(list=objects())
library(magrittr)
library(forecast)
library(zoo)
library(xts)
n <- 100
t <- c(1:n)
s <- cos(2*t*pi/10)
eps = rnorm(n,0,1)
X1 = eps
X2 = eps + t/5
X3 = eps + cos(2*t*pi/10) + t/5
plot(X3, type = 'l', ylim = range(X1,X2,X3))
lines(X2-eps, col = 'red')
lines(X3-eps, col = 'blue')
#### Lissage Simple
expSmooth = function(x,alpha)
{
xSmooth <- x
n <- length(x)
for (i in c(2:n))
{
xSmooth[i] = alpha*x[i] + (1-alpha)*xSmooth[i-1]
}
xSmooth <- c(x[1], head(xSmooth, n-1))
return(xSmooth)
}
aplha = 0.9
X1.smooth <- expSmooth(X1, aplha )
plot(X1, type = 'l')
lines(X1.smooth, col = 'red')
mean((X1 - X1.smooth)^2)
##Optimisation alpha
alpha <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha, expSmooth, x=X1)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X1-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha, erreur, type = 'l')
o <- which.min(erreur)
points(alpha[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X2
aplha = 0.9
X2.smooth <- expSmooth(X2, aplha )
plot(X2, type = 'l')
lines(X2.smooth, col = 'red')
mean((X2 - X2.smooth)^2)
##Optimisation alpha
alpha_X2 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X2, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X2, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X2[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
######X3
aplha = 0.9
X3.smooth <- expSmooth(X3, aplha )
plot(X3, type = 'l')
lines(X3.smooth, col = 'red')
mean((X3 - X3.smooth)^2)
##Optimisation alpha
alpha_X3 <- seq(0.00, 0.95, length = 100)
forecast<-lapply(alpha_X3, expSmooth, x=X3)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-lapply(forecast,function(x){mean((X3-x)^2)})%>%unlist #correspond à faire unlist(lapply...), enfin je pense!
plot(alpha_X3, erreur, type = 'l')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
### Lissage Double
doubleExpSmooth = function(x, aplha)
{
xSmooth <- x
n = length(x)
l <- array(x[1], dim = n)
b <- array(x[2] - x[1], n)
for(i in c(2:n))
{
l[i]<-xSmooth[i-1]+(1-(1-alpha)^2)*(x[i]-xSmooth[i-1])
b[i]<-b[i-1]+alpha^2*(x[i]-xSmooth[i-1])
xSmooth[i]<-l[i]+b[i]
}
res<-list()
res$smooth<-xSmooth
res$l=l
res$b<-b
return(res)
}
alpha <- seq(0.00, 0.95, length = 100)
forecast1<-lapply(alpha, expSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
forecast2<-lapply(alpha, doubleExpSmooth, x=X2)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur1<-lapply(forecast1,function(x){mean((X2-x)^2)})%>%unlist #correspond à faire transformer une liste en vecteur
erreur2<-lapply(forecast2,function(x){mean((X2-x$Smooth)^2)})%>%unlist #correspond à faire transformer une liste en vecteur
graphics.off()
plot(alpha, erreur2, type = 'l')
lines(alpha, erreur1, col = 'blue')
o <- which.min(erreur)
points(alpha_X3[o], erreur[o] + 0.5, col = 'red', pch = 20, cex = 2)
setwd(dir = "/Users/Kilian/Programmation/R_project/MAP_STA2/Projet/Valeurs")
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
dateIni <- strptime(c("01/01/1900"), "%m/%d/%Y")
dateFin <- strptime(c("12/01/2016"), "%m/%d/%Y")
Date <- seq(dateIni, dateFin, by="year")
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
dateIni <- strptime(c("01/01/1900"), "%m/%d/%Y")
dateFin <- strptime(c("12/01/2016"), "%m/%d/%Y")
Date <- seq(dateIni, dateFin, by="year")
n <- length(Date)
t <- c(1:n)
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
dateIni <- strptime(c("01/01/1900"), "%m/%d/%Y")
dateFin <- strptime(c("12/01/2016"), "%m/%d/%Y")
Date <- seq(dateIni, dateFin, by="months")
n <- length(Date)
t <- c(1:n)
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
dateIni <- strptime(c("01/1900"), "%m/%Y")
dateFin <- strptime(c("12/2016"), "%m/%Y")
Date <- seq(dateIni, dateFin, by="months")
n <- length(Date)
t <- c(1:n)
coursPetrole<-read.csv("beer2.csv",header=TRUE,skip=1)
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
coursPetrole<-read.csv("beer2.csv",header=TRUE,skip=1)
coursPetrole<-read.csv("Valeurs.csv",header=TRUE,skip=1)
dateIni <- strptime(c("01/01/1900"), "%m/%d/%Y")
dateFin <- strptime(c("12/01/2016"), "%m/%d/%Y")
Date <- seq(dateIni, dateFin, by="months")
n <- length(Date)
t <- c(1:n)
head(coursPetrole)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
coursPetrole<-read.csv("Valeurs.csv",header=TRUE,skip=1)
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
coursPetrole<-read.csv("Valeurs.csv",header=TRUE,skip=1)
head(coursPetrole)
plot(coursPetrole)
plot(coursPetrole$Couts)
plot(coursPetrole$Couts)
plot(coursPetrole$Couts,type='b',pch=20)
head(coursPetrole)
plot(coursPetrole$Couts,type='b',pch=20)
plot(coursPetrole,type='b',pch=20)
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/TP1/")
beer<-read.csv("beer2.csv",header=TRUE,skip=1)
head(beer)
plot(beer$BeerProd,type='b',pch=20)
plot(coursPetrole$couts,type='b',pch=20)
coursPetrole<-read.csv("Valeurs.csv",header=TRUE,skip=1)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
coursPetrole<-read.csv("Valeurs.csv",header=TRUE,skip=1)
head(coursPetrole)
plot(coursPetrole$couts,type='b',pch=20)
head(beer)
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/Valeurs")
coursPetrole<-read.csv("Valeurs.csv",header=TRUE,skip=1)
head(coursPetrole)
plot(coursPetrole$couts,type='b',pch=20)
dateIni <- strptime(c("01/01/1900"), "%m/%d/%Y")
dateFin <- strptime(c("12/01/2016"), "%m/%d/%Y")
Date <- seq(dateIni, dateFin, by="months")
n <- length(Date)
t <- c(1:n)
