plot(oilPriceDate$Date, MA2 - mb, type = 'l')
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
######Data import
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/oil-price-evolution/Valeurs")
oilPriceValue<-read.table("Valeurs.csv", sep = ';', dec = ",", skip = 1)
head(oilPriceValue)
plot(oilPriceValue)
######Data Frame
dateEnd <- strptime(c("01/01/1990"), "%m/%d/%Y")
dateStart <- strptime(c("12/01/2016"), "%m/%d/%Y")
Date <- seq(dateStart, dateEnd, by = "-1 month")
oilPriceDate<-data.frame(Date, oilPriceValue$V3)
names(oilPriceDate)<-c("Date", "price")
plot(oilPriceDate$Date, oilPriceDate$price, type = 'l')
######Classe ts
oilPriceDate.ts <- ts(oilPriceDate$price, start = 1, frequency = 12) #frequency -> saisonnality time is 1 year
plot(oilPriceDate.ts)
######Classe zoo
oilPriceDate.zoo <- zoo(oilPriceDate$price, order.by = oilPriceDate$Date)
plot(oilPriceDate.zoo)
######Essentials stats
mean(oilPriceDate$price)
sd(oilPriceDate$price)
summary(oilPriceDate$price)
boxplot(oilPriceDate$price)
hist(oilPriceDate$price)
######Trend
#mobile mean
mb<-filter(oilPriceDate$price, filter = array(1/50, dim = 50), method = c("convolution"),
sides = 2, circular = FALSE)
mb<-xts(mb, order.by = oilPriceDate$Date)
plot(oilPriceDate$Date, oilPriceDate$price, type = 'l')
lines(mb, col = 'red')
#Differenciation by autocorrelation
oilPriceDate.ts <- ts(oilPriceDate$price, start = 1, frequency = 27) #frequency -> saisonnality time is 1 year
plot(oilPriceDate.ts)
Acf(oilPriceDate.ts, na.action = na.omit)
diff.oilPriceDate.ts <- diff(oilPriceDate.ts, lag = 1, differences = 1)
Acf(diff.oilPriceDate.ts, na.action = na.omit)
plot(oilPriceDate.ts)
plot(diff.oilPriceDate.ts)
#parametrique trend
time <- c(1:nrow(oilPriceDate))
oilPriceDate$time <- time
reg <- lm(price ~ time + I(time^2) + I(time^3) + I(time^4), data = oilPriceDate)
summary(reg)
#par(mfrow = c(1, 2))
plot(oilPriceDate$Date, oilPriceDate$price, type = "l", xlab = "months",
ylab = "Ind. Price .Oil .In .London (INSEE)", col = "blue")
lines(oilPriceDate$Date, reg$fitted, col = "red", lwd = 2)
plot(oilPriceDate$Date, oilPriceDate$price - reg$fitted, type = "l",
xlab = "months", ylab = "Ind. Prix. - detrend", col = "orangered2")
####Courbe rouge - courbe bleu
#Kernel estimation
noyau <- ksmooth(oilPriceDate$time, oilPriceDate$price, kernel = c("normal"), bandwidth = 10)
#par(mfrow = c(1, 2))
plot(oilPriceDate$Date, oilPriceDate$price, type = "l", xlab = "",
ylab = "Ind. Price. Brent. London (INSEE)", col = "blue")
lines(oilPriceDate$Date, noyau$y, col = "red", lwd = 2)
plot(oilPriceDate$Date, oilPriceDate$price - noyau$y, type = "l",
xlab = "", ylab = "Ind. Prix. - detrend", col = "orangered2")
#local Polynomial estimation
graphics.off()
loc<-loess (price ~ time, dat=oilPriceDate, degree=2, span=0.5) #span sur le pourcentages de valeurs prises dans la fenêtre
loc2<-loess (price ~ time, dat=oilPriceDate, degree=2, span=0.2)
loc3<-loess (price ~ time, dat=oilPriceDate, degree=1, span=0.2)
plot(oilPriceDate$Date,oilPriceDate$price, type='l',xlab="months", ylab="Oil barril price(INSEE)", col= "blue")
lines(oilPriceDate$Date, loc$fitted, col='red', lwd=2)
lines(oilPriceDate$Date, loc2$fitted, col='orange', lwd=2)
lines(oilPriceDate$Date, loc3$fitted, col='green', lwd=2)
#################Seasonality per year
## Enlever la tendance
#mobile mean
##saionnalité sur 1 an
MA<-filter(oilPriceDate$price, filter = array(1/(27), dim = 27), method = c("convolution"),
sides = 2, circular = FALSE)
##suite aux schémas, on observe une saisonnalité sur 6 ans
MA2<-filter(oilPriceDate$price, filter = array(1/(27*6), dim = 27*6), method = c("convolution"),
sides = 2, circular = FALSE)
plot(oilPriceDate$Date, oilPriceDate$price - loc3$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc3$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc3$fitted, col = 'red')
plot(oilPriceDate$Date, MA2 - loc3$fitted, type = 'l')
plot(oilPriceDate$Date, oilPriceDate$price - loc3$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc3$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc3$fitted, col = 'red')
plot(oilPriceDate$Date, oilPriceDate$price - loc3$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc3$fitted, col = 'blue')
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc3$fitted, col = 'blue')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
plot(oilPriceDate$Date, oilPriceDate$price - loc$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc$fitted, col = 'blue')
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc2$fitted, col = 'red')
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc2$fitted, col = 'red')
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
MA2<-filter(oilPriceDate$price, filter = array(1/(27*6), dim = 27*6), method = c("convolution"),
sides = 2, circular = FALSE)
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc2$fitted, col = 'red')
MA2<-filter(oilPriceDate$price, filter = array(1/(27*5), dim = 27*5), method = c("convolution"),
sides = 2, circular = FALSE)
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc2$fitted, col = 'red')
MA2<-filter(oilPriceDate$price, filter = array(1/(27*3), dim = 27*3), method = c("convolution"),
sides = 2, circular = FALSE)
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc2$fitted, col = 'red')
MA2<-filter(oilPriceDate$price, filter = array(1/(27*7), dim = 27*7), method = c("convolution"),
sides = 2, circular = FALSE)
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
lines(oilPriceDate$Date,MA2 - loc2$fitted, col = 'red')
MA<-filter(oilPriceDate$price, filter = array(1/(27), dim = 27), method = c("convolution"),
sides = 2, circular = FALSE)
MA<-filter(oilPriceDate$price, filter = array(1/(27), dim = 27), method = c("convolution"),
sides = 2, circular = FALSE)
MA<-filter(oilPriceDate$price, filter = array(1/(27), dim = 27), method = c("convolution"),
sides = 2, circular = FALSE)
MA<-filter(oilPriceDate$price, filter = array(1/(27), dim = 27), method = c("convolution"),
sides = 2, circular = FALSE)
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
dateIni <- strptime(c("01/01/1900"), "%m/%d/%Y")
dateFin <- strptime(c("01/01/2000"), "%m/%d/%Y")
Date <- seq(dateIni, dateFin, by="year")
n <- length(Date)
t <- c(1:n)
t
#2
w = 2*pi/50
Tt = t/20 + 1
St = cos(w*t) + sin(w*t)
set.seed(100)
Eps_t = rnorm(n,0,1)
par(mfrow = c(1,1))
X <- Tt + St + Eps_t
X <- xts(X, order.by = Date)
Tt <- xts(Tt, order.by = Date)
St <- xts(St, order.by = Date)
plot(X) # Print la Tendance + Saisonnalité + bruit
lines(Tt, col = 'red') #Print la Tendance
lines(St + Tt, col = 'blue') #Print la Tendance + Saisonnalité
model = lm(X ~ Tt, data = Date)
ychap.lm <- xts(as.numeric(model$fitted),order.by = Date)
plot(X, type = 'l')
lines(ychap.lm, col = 'red')
l <- 50
MA <- filter(X, filter=array(1/l, dim = l),
method = c("convolution"), sides = 2, circular = FALSE) #circu = FALSE commence la ou il y a 10 para de chaque cotés
MA <- xts(MA, order.by = Date)
plot(X, type ='l')
lines(MA, col = 'red')
h <- 1000
mb.season<-filter(X.detrend, filter=array(1/20,dim=20), method = c("convolution"),
sides = 2, circular = FALSE)
mb.season<-xts(mb.season,order.by=Date)
plot(X.detrend,type='l')
lines(mb.season,col='red')
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
dateIni <- strptime(c("01/01/1900"), "%m/%d/%Y")
dateFin <- strptime(c("01/01/2000"), "%m/%d/%Y")
Date <- seq(dateIni, dateFin, by="year")
n <- length(Date)
t <- c(1:n)
t
#2
w = 2*pi/50
Tt = t/20 + 1
St = cos(w*t) + sin(w*t)
set.seed(100)
Eps_t = rnorm(n,0,1)
par(mfrow = c(1,1))
X <- Tt + St + Eps_t
X <- xts(X, order.by = Date)
Tt <- xts(Tt, order.by = Date)
St <- xts(St, order.by = Date)
plot(X) # Print la Tendance + Saisonnalité + bruit
lines(Tt, col = 'red') #Print la Tendance
lines(St + Tt, col = 'blue') #Print la Tendance + Saisonnalité
########### Regression
model = lm(X ~ Tt, data = Date)
ychap.lm <- xts(as.numeric(model$fitted),order.by = Date)
plot(X, type = 'l')
lines(ychap.lm, col = 'red')
#modèle linéaire --> dépendance selon toutes les variables
#########Moyenne Mobile
l <- 50
MA <- filter(X, filter=array(1/l, dim = l),
method = c("convolution"), sides = 2, circular = FALSE) #circu = FALSE commence la ou il y a 10 para de chaque cotés
MA <- xts(MA, order.by = Date)
plot(X, type ='l')
lines(MA, col = 'red')
########Noyau Gaussien
h <- 1000
x <- seq(1, max(t), length(n))
W <- matrix(unlist(lapply(X,function(x){dnorm(x-t,0,sd=sqrt(h/2))/sum(dnorm(x-t,0,sd=sqrt(h/2)))})),ncol=n,nrow=n,byrow=F)
plot(W[,50])
plot(W[,10])
matplot(W, type = 'l', lty = 1, col = rainbow(n)) #print matrice
ychap.kernel <- colSums(as.numeric(x)*W)
ychap.kernel <- xts(ychap.kernel, order.by = Date)
plot(X, type = 'l')
lines(ychap.kernel, col = 'red')
#W
########Polynomes locaux
lo <- loess(X ~ t, degree = 1, span = 0.9)
ychap.lo <- xts(lo$fitted, order.by = Date)
plot(X, type = 'l')
lines(ychap.lo, col = 'red')
######Regression sur bases de splines
library(mgcv)
g <- gam(X~s(t,k = 3))
ychap.gam <- xts(g$fitted, order.by = Date)
plot(X, type = 'l')
lines(ychap.gam, col = 'red')
####Estimation de la partition saisonnière
X.detrend <- X-ychap.lm
plot(X.detrend)
w = 2*pi/50
fourier <- cbind(cos(w*t), sin(w*t))
K <- 2
for (i in c(2:K))
{
fourier <- cbind(fourier, cos(i*w*t), sin(i*w*t))
}
matplot(fourier, type = 'l')
reg <- lm(X.detrend~fourier)
ychap.lm.season<-xts(as.numeric(reg$fitted),order.by=Date)
plot(X.detrend,type='l')
lines(ychap.lm.season,col='red')
lines(St,col='blue')
mb.season<-filter(X.detrend, filter=array(1/20,dim=20), method = c("convolution"),
sides = 2, circular = FALSE)
mb.season<-xts(mb.season,order.by=Date)
plot(X.detrend,type='l')
lines(mb.season,col='red')
lines(St,col='blue')
rm(list=objects())
library(zoo)
library(timeDate)
library(forecast)
library(xts)
library(dygraphs)
######Data import
setwd(dir = "/Users/Kilian/Programmation/ENSTA_2A/R_project/MAP_STA2/Projet/oil-price-evolution/Valeurs")
oilPriceValue<-read.table("Valeurs.csv", sep = ';', dec = ",", skip = 1)
head(oilPriceValue)
plot(oilPriceValue)
######Data Frame
dateEnd <- strptime(c("01/01/1990"), "%m/%d/%Y")
dateStart <- strptime(c("12/01/2016"), "%m/%d/%Y")
Date <- seq(dateStart, dateEnd, by = "-1 month")
oilPriceDate<-data.frame(Date, oilPriceValue$V3)
names(oilPriceDate)<-c("Date", "price")
plot(oilPriceDate$Date, oilPriceDate$price, type = 'l')
######Classe ts
oilPriceDate.ts <- ts(oilPriceDate$price, start = 1, frequency = 12) #frequency -> saisonnality time is 1 year
plot(oilPriceDate.ts)
######Classe zoo
oilPriceDate.zoo <- zoo(oilPriceDate$price, order.by = oilPriceDate$Date)
plot(oilPriceDate.zoo)
######Essentials stats
mean(oilPriceDate$price)
sd(oilPriceDate$price)
summary(oilPriceDate$price)
boxplot(oilPriceDate$price)
hist(oilPriceDate$price)
######Trend
#mobile mean
mb<-filter(oilPriceDate$price, filter = array(1/50, dim = 50), method = c("convolution"),
sides = 2, circular = FALSE)
mb<-xts(mb, order.by = oilPriceDate$Date)
plot(oilPriceDate$Date, oilPriceDate$price, type = 'l')
lines(mb, col = 'red')
#Differenciation by autocorrelation
oilPriceDate.ts <- ts(oilPriceDate$price, start = 1, frequency = 27) #frequency -> saisonnality time is 1 year
plot(oilPriceDate.ts)
Acf(oilPriceDate.ts, na.action = na.omit)
diff.oilPriceDate.ts <- diff(oilPriceDate.ts, lag = 1, differences = 1)
Acf(diff.oilPriceDate.ts, na.action = na.omit)
plot(oilPriceDate.ts)
plot(diff.oilPriceDate.ts)
#parametrique trend
time <- c(1:nrow(oilPriceDate))
oilPriceDate$time <- time
reg <- lm(price ~ time + I(time^2) + I(time^3) + I(time^4), data = oilPriceDate)
summary(reg)
#par(mfrow = c(1, 2))
plot(oilPriceDate$Date, oilPriceDate$price, type = "l", xlab = "months",
ylab = "Ind. Price .Oil .In .London (INSEE)", col = "blue")
lines(oilPriceDate$Date, reg$fitted, col = "red", lwd = 2)
plot(oilPriceDate$Date, oilPriceDate$price - reg$fitted, type = "l",
xlab = "months", ylab = "Ind. Prix. - detrend", col = "orangered2")
####Courbe rouge - courbe bleu
#Kernel estimation
noyau <- ksmooth(oilPriceDate$time, oilPriceDate$price, kernel = c("normal"), bandwidth = 10)
#par(mfrow = c(1, 2))
plot(oilPriceDate$Date, oilPriceDate$price, type = "l", xlab = "",
ylab = "Ind. Price. Brent. London (INSEE)", col = "blue")
lines(oilPriceDate$Date, noyau$y, col = "red", lwd = 2)
plot(oilPriceDate$Date, oilPriceDate$price - noyau$y, type = "l",
xlab = "", ylab = "Ind. Prix. - detrend", col = "orangered2")
#local Polynomial estimation
graphics.off()
loc<-loess (price ~ time, dat=oilPriceDate, degree=2, span=0.5) #span sur le pourcentages de valeurs prises dans la fenêtre
loc2<-loess (price ~ time, dat=oilPriceDate, degree=2, span=0.2)
loc3<-loess (price ~ time, dat=oilPriceDate, degree=1, span=0.2)
plot(oilPriceDate$Date,oilPriceDate$price, type='l',xlab="months", ylab="Oil barril price(INSEE)", col= "blue")
lines(oilPriceDate$Date, loc$fitted, col='red', lwd=2)
lines(oilPriceDate$Date, loc2$fitted, col='orange', lwd=2)
lines(oilPriceDate$Date, loc3$fitted, col='green', lwd=2)
#################Seasonality per year
## Enlever la tendance
#mobile mean
##saionnalité sur 1 an
MA<-filter(oilPriceDate$price, filter = array(1/(27), dim = 27), method = c("convolution"),
sides = 2, circular = FALSE)
##suite aux schémas, on observe une saisonnalité sur 6 ans
plot(oilPriceDate$Date, oilPriceDate$price - loc2$fitted, type = 'l')
lines(oilPriceDate$Date,MA - loc2$fitted, col = 'blue')
######differenciation
par(mfrow = c(1, 2))
acf(oilPriceDate.ts)
acf(diff(oilPriceDate.ts, lag = 5, differences = 1))
##Lissage exponentiel:
graphics.off()
#lissage simple:
expSmooth=function(x,alpha)
{
xsmooth<-x
n<-length(x)
for (i in c(2:n))
{
xsmooth[i]<-(1-alpha)*xsmooth[i-1]+alpha*x[i]# xsmooth[i] correspond à y^t+1  /t
}
xsmooth<-c(x[1],head(xsmooth,n-1))#décalage de 1 de la série, parce que xsmooth[i] correspond à y^t+1  /t
return (xsmooth)
}
alpha<-0.9
X1<-oilPriceDate$price
X1<-X1[324:1] #pour remettre les valeurs dans le bon sens (critère estétique plus qu'autre chose)
X1.smooth<-expSmooth(X1,alpha)
plot(X1,type='l')
lines(X1.smooth, col='red')
alpha2<-0.1
X1.smooth2<-expSmooth(X1,alpha2)
lines(X1.smooth2, col='blue')
#Trouver le alpha optimal
mean((X1-X1.smooth)^2)
alpha<-seq(0.00,0.95,length=100)
forecast<-lapply(alpha, expSmooth, x=X1)#calcule la moyenne etc d'une matrice, revoie une liste mais on veut un vecteur
erreur<-unlist(lapply(forecast,function(x){mean((X1-x)^2)}))
plot(alpha, erreur, type='l')
alpha_opt<-which.min(erreur)#trouve le minimum de la fonction
points(alpha[alpha_opt],erreur[alpha_opt],col='red', pch=20,cex=2)#que fait cex
text(alpha[alpha_opt],erreur[alpha_opt]+0.5, labels=alpha[alpha_opt]%>%round(digits=3))
alphaX1=alpha[alpha_opt]
#on trouve alphaX2 (donc l'optimal)=0.95 je ne sais pas si c'est vraiment bien: cela signifierait qu'on ne peut pas prendre en compte la stabilitité mais plutot les variations
#lissage double
#h est l'horizon
h<-1
DoubleExpSmooth=function(x,alpha)
{
xsmooth=x
n<-length(x)
l<-array(x[1],dim=length(x))
b<-array(x[2]-x[1], dim=length(x)) #initialisation
for (i in c(2:n))
{
l[i]<-l[i-1]+b[i-1]+(1-(1-alpha)^2)*(x[i]-xsmooth[i-1])
b[i]=b[i-1]+(x[i]-xsmooth[i-1])*alpha^2
xsmooth[i]=l[i]+b[i]*h
}
res<-list()
res$smooth<-xsmooth
res$l=l
res$b<-b
return(res)
}
alpha<-seq(0.05, 0.95, length=100)
forecast1<-lapply(alpha,expSmooth,x=X1)
forecast2<-lapply(alpha, DoubleExpSmooth,x=X1)
erreur1<-unlist(lapply(forecast1, function(x){mean((X1-x)^2)}))
erreur2<-unlist(lapply(forecast2, function(x){mean((X1-x$smooth)^2)}))  # pourquoi $smooth??
plot(alpha,erreur2,type='l',ylim=range(erreur2,erreur1),col='blue')
lines(alpha,erreur1, type='l')
opt<-which.min(erreur2)
points(alpha[opt],erreur2[opt],col='red', pch=20, cex=2)
text(alpha[opt],erreur2[opt]+4, labels=alpha[opt]%>%round(digits=3))
text(alpha[opt]+0.05,erreur2[opt]+4, labels=min(erreur2)%>%round(digits=3))
alphaX1_D=alpha[opt]
X1.smooth<-expSmooth(X1,alphaX1)
X1.smooth_D<-DoubleExpSmooth(X1,alphaX1_D)
plot(X1,type='l')
lines(X1.smooth_D$smooth,col='red')
lines (X1.smooth,col='blue')
plot(X1.smooth_D$l,type='l',ylim=range(X1.smooth_D$l,X1.smooth_D$b), col='blue')
lines(X1.smooth_D$b,type='l', col='green')
#Ici, on a les tracés des valeurs de b[i] et l[i], J'avoue que je ne comprends pas bien l'interet de cela, je le laisse mais sauf si tu comprends le mieux serait de l'enlever pour rendre notre travail
##Cela doit servir à determiner la période de convergence: mais je ne comprends pas bien comment; surtout qu'elle semble quasi inexistante au vue du graphe et même des b[i]
#En réalité on va voir juste après que lorsque j'enlève une période de cv, l'erreur quadratique augmente! Ce qui est toujours un tantinet étrange, il est normal qu'elle change de valeur mais pas forcement pour une augmentation..
#en essayant avec 0, je pense qu'il ne s'agit que d'un hasard, ou alors c'est que le début est particulièrement bien suivit car plus  stable (ce qui me semble le plus logique!)
erreur1<-unlist(lapply(forecast1, function(x){mean((X1[0:324]-x[0:324])^2)}))
erreur2<-unlist(lapply(forecast2, function(x){mean((X1[0:324]-x$smooth[0:324])^2)}))  # pourquoi $smooth??
plot(alpha,erreur2,type='l',ylim=range(erreur1,erreur2),col='blue')
lines(alpha,erreur1, type='l')
opt<-which.min(erreur2)
points(alpha[opt],erreur2[opt],col='red', pch=20, cex=2)
text(alpha[opt],erreur2[opt]+4, labels=alpha[opt]%>%round(digits=3))
text(alpha[opt]+0.05,erreur2[opt]+4, labels=min(erreur2)%>%round(digits=3))
alphaX1_D=alpha[opt]
#lissage exponentiel de Holt Winters (saisonalité)
#La chute brutale après la bulle de 2008 peut faire penser à un modèle multiplicatif
## + vision globale du graphe: volatilité semble proportionelle au prix
## On essayera tout de même les deux modèles!
#modèle multiplicatif:
#T=saisonalité: 12 mois (la plus petite non?)
SeasonalMultiplicatifDoubleExpSmooth=function(x,alpha,beta,delta,T)
{
xsmooth=x
n<-length(x)
l<-array(x[1],dim=length(x))
b<-array(x[2]-x[1], dim=length(x)) #initialisation
s<-array(x[1],dim=length(x))
for (i in c(13:n))
{
l[i]<-alpha*(x[i]/s[i-T])+(1-alpha)*(l[i-1]+b[i-1]) #T est la période
b[i]=beta*(l[i]-l[i-1])+(1-beta)*b[i-1]
s[i]=delta*(xsmooth[i]/l[i])+(1-delta)*s[i-T]
xsmooth[i]=(l[i]+b[i]*h)*s[i]
}
res<-list()
res$smooth<-xsmooth
res$l=l
res$b<-b
return(res)
}
h<-1
T<-12
X1.SeasonalMultiplicatifDoubleExpSmooth=SeasonalMultiplicatifDoubleExpSmooth(X1, 0.2, 0.2, 0.2, 72)
plot(X1,type='l',ylim=range(X1,X1.SeasonalMultiplicatifDoubleExpSmooth$smooth))
lines(X1.SeasonalMultiplicatifDoubleExpSmooth$smooth, col='red')
#Terrrrible!
X2.SeasonalMultiplicatifDoubleExpSmooth=SeasonalMultiplicatifDoubleExpSmooth(X1, 0.2, 0.2, 0.2, 12)
plot(X1,type='l',ylim=range(X1,X2.SeasonalMultiplicatifDoubleExpSmooth$smooth))
lines(X2.SeasonalMultiplicatifDoubleExpSmooth$smooth, col='red')
#Et visiblement pas mieux en prenant la période plus importante!
X2.SeasonalMultiplicatifDoubleExpSmooth=SeasonalMultiplicatifDoubleExpSmooth(X1, 0.9, 0.1, 0.1, 12)
plot(X1,type='l',ylim=range(X1,X2.SeasonalMultiplicatifDoubleExpSmooth$smooth))
lines(X2.SeasonalMultiplicatifDoubleExpSmooth$smooth, col='red')
#ok on peut jouer avec les paramètres..J' ai un peu la flemme de le faire maintenant mais on regardera cela de plus près: ici le lissage est tout de même fort proche de l'allure de la courbe!
# Bon tentons le lissage saisonalité additive:
SeasonalAdditifDoubleExpSmooth=function(x,alpha,beta,delta,T)
{
xsmooth=x
n<-length(x)
l<-array(x[1],dim=length(x))
b<-array(x[2]-x[1], dim=length(x)) #initialisation
s<-array(x[1],dim=length(x))
for (i in c(13:n))
{
l[i]<-alpha*(x[i]-s[i-T])+(1-alpha)*(l[i-1]+b[i-1]) #T est la période
b[i]=beta*(l[i]-l[i-1])+(1-beta)*b[i-1]
s[i]=delta*(xsmooth[i]-l[i])+(1-delta)*s[i-T]
xsmooth[i]=l[i]+b[i]*h+s[i]
}
res<-list()
res$smooth<-xsmooth
res$l=l
res$b<-b
return(res)
}
h<-1
T<-12
X1.SeasonalAdditifDoubleExpSmooth=SeasonalAdditifDoubleExpSmooth(X1, 0.2, 0.2, 0.2, 12)
plot(X1,type='l',ylim=range(X1,X1.SeasonalAdditifDoubleExpSmooth$smooth))
lines(X1.SeasonalAdditifDoubleExpSmooth$smooth, col='red')
#Visiblement légèrement mieux..
par(mfrow = c(1, 2))
acf(oilPriceDate.ts)
acf(diff(oilPriceDate.ts, lag = 5, differences = 1))
acf(oilPriceDate.ts- loc2$fitted)
acf(diff(oilPriceDate.ts- loc2$fitted, lag = 5, differences = 1))
acf(oilPriceDate.ts)
acf(diff(oilPriceDate.ts, lag = 5, differences = 1))
